---
title: "OAuth 2.0"
permalink: /post/oauth-2
layout: default
tags: OAuth-2.0 Authorization Authentication Authorization-Code-Flow PKCE ROPC Device-Authorization-Flow Implicit-Flow  Access-Token Third-Party-Access 
is_series: true
series_title: "Web Security"
series_number: 5
---

OAuth 2.0 both improves and expands upon OAuth 1.0, with simpler authentication processes, and a modular approach that allows for additional use-cases besides server-based Client App authorization.

[Notes on Terminology](#notes-on-terminology)

In fact, OAuth 2.0 offers several 'flows', are appropriate for different scenarios. We'll give a brief overview of them before delving into the implementation details of some of the more significant ones for a variety of reasons, their widespread use, their security vulnerabilities or mitigatations against them, or their particular use case.

### Overview of OAuth 2.0 Flows

1) **Authorization Code Flow**

    Most similar to the OAuth 1.0 flow, used for server-based Client Applications, but easier to implement than OAuth 1.0.

    [Implementing Authorization Code Flow](#implementing-authorization-code-flow)

2) **Implict Flow (also called Implict Grant Flow)**

    Designed for applications that cannot fully secure application-specific secrets required for ensuring request authenticity.

    This includes Single Page Applications with zero server-side functionality, and native applications including mobile and desktop applications operating without a secure server backend.

    Implict Flow issues Access Tokens directly after user authorization. Has significant security vulnerabilities and its use is [no longer recommended](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-17.html#name-implicit-grant) by the IETF.
    
    [Implementing Implicit Flow](#implementing-implicit-flow)

3) **Authorization Code Flow with PKCE (Proof Key for Code Exchange)**

    The recommended alternative to Implicit Flow for applications unable to secure a client secret.

    The flow is similar to the standard OAuth 2.0 [Authorization Code Flow](#authorization-code-flow). It has fewer vulnerabilities than Implicit Flow, with PKCE limiting the Access Token's visibility and risk of interception; and ensuring the Access Token can only be received by the instance of the Client App in use by the authenticated user.
    
    [Implementing Authorization Flow with PKCE](#implementing-PKCE-flow)

4) **Resource Owner Password Credentials (ROPC)**

    With ROPC, a user enters their credentials directly into the Client App, which then forwards them in an API request to the Authorization Server for authentication. The Authorization Server then returns an Access Token for the Service Provider.

    It is generally not recommended for applications operating on the open internet, and goes against the main rationale of OAuth which is enabling Client Applications authorized access to Service Providers without sharing user credentials.

    However an example use case for ROPC could be when a Client Application is highly trusted, and interacts with the Authorization Server within a closed network, such as a secure company intranet. 

4) **Client Credentials Flow**

    This is generally used for server-to-server communication with no user resource access required. 

    The Client Application authenticates itself with the Authorization Server, and receives an Access Token for the Service Provider. 

    The Client Application should be server-based to store their credentials securely.

5) **Device Authorization Flow**

    Device Authorization Flow is designed for authorizing Client Apps that run on a different device than one the user will use to authenticate with.

    Typically this is implemented for authorizing Client Applications on devices such as TVs, where user credential input is physically difficult or slow.

    Temporary user and device codes are generated to link the user's service account authorization with the device of the Client App requesting access 


    [Implementing Device Authorization Flow](#implementing-device-authorization-flow)


### Implementing Authorization Code Flow

This is most similar to the OAuth 1.0 flow. It is appropriate for server-based Client Apps, that can securely store Access Tokens from an Authentication Server.

1) **App Registration**

    First, like in OAuth 1.0, the Client App developers register the app with the Service Provider.

    During registration the app is assigned a 'client_id', a unique identifer for the app, and a 'client_secret', used for authenticating the app when requesting Access Tokens and should be kept confidential.
    
    In addition, during registration a 'redirect_uri' must be provided, pointing to the Client App that ensures the Authorization Server will send the user back to the genuine Client App after user authorization.

2) **User Authorization Request**

    When the user authorization flow is initiated, a URL is generated by the client server directing the browser to the Authorization Server, with a number of parameters set allowing the Authorization Server to know the Client App authorizing and the permissions being requested:

    **'client_id'** - the Client App's unique identifer 
    
    **'response_type'** - this is set to 'code' which indicates the app is initiating the Authorization Code Flow
    
    **'scope'** - the list of permissions the Client App is asking the user to authorize
    
    **'redirect_uri'** - the URI of the Client App that must match the one registered with the Service Provider.
    
    **'state'** - a randomly value generated by the client server specifically for the authorization request and saved to the user's session. The state value is used to protect against CSRF attacks. 
    
    A CSRF attack, by definition, tricks the user into initiating a request from a location outside of the genuine client site, such as from within an email or another site. Since the state value is generated for each user authentication session, when the same value is returned by the Authorization Server it confirms the response is for the same request that was initiated by the user.
    
    While the client_id and redirect_uri also to some degree confirm to the Authorization Server that the request came from a valid source, they are at risk of being intercepted by an attacker and used to mimic an genuine authorization request. It is only when the client server compares the state value from the authorization response to the one it generated for the user session that the response can verified as genuine and the authorization flow can continue.

3) **Temporary Authorization Code Granted** 

    After the user successfully authenticates with the Authorization Server and authorizes the Client App's requested permissions, the Authorization Server redirects the user's browser back to the Client App via the redirect_uri, appending the 'scope' and 'code' as query parameters to the URL. The 'code' value is the Temporary Authorization Code the Client App will use to obtain an Access Token.
    
    The Client App's server then makes a POST request to a specific token exchange endpoint on the Authorization Server. 
    
    The POST request contains the parameters:
    
    **'grant-type'** - "authorization_code" to tell the Authorization Server this is the Authorization code flow
    
    **'code'** - the Temporary Authorization Code 
    
    **'redirect_uri'**  - as sent in the authorization request
    
    **'client_id'** - the app's unique identifer
    
    **'client_secret'** - the app's secret from its initial registration
     
    These parameters should be sent as URL-encoded form data in the request body, to protect sensitive data, especially the 'client_secret' that must be kept confidential.

4) **Access Token Exchange** 

    When the Authorization Server receives the POST request at the token exchange endpoint, it validates that the 'client_id', 'client_secret' and 'redirect_uri' match a registered app, and the 'code' - the Temporary Authorization Code - has not expired and was issued for the app corresponding to the 'client_id' and 'client_secret'.
    
    Assuming the validation is successful, the server sends a response back to the Client App's server containing a JSON object with:
    
    ```json
    { 
        'access_token': <Access Token value>,
        'token_type': Bearer,
        'expires_in': <the number of seconds the token is valid>,
        'refresh_token': <optional, a Refresh Token used to obtain a new Access Token when the issued one expires>
    }
    ```
    
    This data stored on the server and associated with the user.
    
    The client server can then make API requests to the Service Provider for permitted resources on behalf of the user, by including the header:
    
    ```
    Authorization: Bearer <Access Token>
    ```
    
    By making these requests from the server, the Access Token is not exposed to the user's browser and remains secure. 

5) **Refresh Tokens**


To avoid requiring the user re-authorize when their Access Token expires, a Client App can either:

1) Use Refresh *Tokens to gain fresh Access Tokens - if Refresh Tokens are supported by the OAuth 2.0 implementation

2) Have very-long lifetime Access Tokens - but these are at a greater risk of being exposed since they are sent with every request. Also not all OAuth 2.0 implementations support Access Token revokation.

#### Obtaining fresh Access Tokens with a Refresh Token

Access Tokens expire when the 'expires_in' time, set in the JSON sent from the token exchange endpoint, is reached. It is often prudent to gain a fresh Access Token at a set time before this expiry is reached, to maintain app continuity for the user.

When a fresh Access Token is required, the Client App server makes a POST request to the same token exchange endpoint on the Authorization Server that was called to in step 3) to gain the first Access Token.

The POST request should include in the request body, as URL-encoded form data:

'grant_type' - "refresh_token"

'refresh_token' - the Refresh Token from a secure store

'client_id' - the app's unique identifer

'client_secret' - the app's secret from a secure store

'scope' - the requested scopes, or omitted if the new Access Token is to have the same access as the expiring one

Assuming the request, along with the Refresh Token, is validated, the token exchange will typically respond with the JSON:

```json
{ 
    'access_token': <New Access Token value>,
    'token_type': Bearer,
    'expires_in': <the number of seconds the new token is valid>,
    'scope': <optional, a list of scopes the new token has access to, if new scopes were set in the refresh request>
    'refresh_token': <optional, an updated Refresh Token used to obtain the next Access Token when the updated one expires>
}
```

However the exact JSON contents may vary with the OAuth 2.0 implementation. Some implementations may issue a new Refresh Token each time, others may only ever require the original for refresh Access Token requests.

This data is then linked to the authorized user and the new Access Token used as before.


### Implicit Flow - Implementation and Vulnerabilities

Client-side applications are generally considered less secure at storing sensitive information like client secrets. 

In the case of SPAs, source code is accessible, and developer tools make it easy to find secrets stored in the browser. They can be vulnerable to XSS attacks, allowing malicious scripts access to browser storage.

Mobile apps, while often running on platforms that do offer some mechanisms for secure storage, are still vulnerable when faced with a determined attacker armed with reverse-engineering and debugging tools. [Here's a comprehensive explanation](https://ivrodriguez.com/why-embedding-secrets-in-mobile-apps-is-not-a-good-idea/)

OAuth 2.0 has two flows designed specifically for client-side applications, Implicit Flow and Authorization Code Flow with PKCE. Implicit Flow is mostly regarded as an insecure implementation, and has been largely superseeded by the more secure Authorization Code Flow with PKCE.

However let's briefly examine Implicit Flow's implementation and it's vulnerabilities, and show how Authorization Code Flow with PKCE improves on it.

### Implicit Flow process

1) As with standard Authorization Code Flow, we register our app's details with a Service Provider, including a unique client_id and a redirect_uri that the Authorization Server will direct the user after authorization.

2) Authorization request construction

To authorize the Client App, the app constructs a URL pointing to the Authorization Server, along with the query parameters:

**'client_id'** - the app's unique identifer

**'scope'** - the list of permissions the Client App is asking the user to authorize

**'redirect_uri'** - the uri of the Client App that must match the one registered with the Service Provider.

**'state'** - a randomly value generated by the client specifically for the authorization request and saved to the user's session. The state value is used to protect against CSRF attacks, explained in detail ******here******

**'response_type'** - token (indicating the Client App wants to receive the Access Token directly)

When the user wishes to authorize the Client App, this URL is opened in a new tab sending the authorization request as a GET request to the Authorization Server.

3) In the new tab displaying the Authorization Server's authentication screen, the user authenticates with their credentials and authorizes the app with its requested permissions (defined in the 'scope' query parameter).

4) After the user has granted authorization, the user is redirected back to the Client App via the 'redirect_uri'. 

The Access Token, along with the standard OAuth token parameters such as expiry time, are included in the URL as part of the URL fragment:

https://my-spa.com/callback#access_token=akb982234huiwa&token_type=bearer&expires_in=3600&state=32fasq3q3qr

The Access Token and other parameters are sent as a URL fragment (everything after the #) because URL fragments aren't sent to the server. Even if our server does nothing except return the SPA content, it still may log or monitor requests, and this prevents the sensitive data being recorded in these logs. Browser caches also store URLs with query parameters. 
5) The SPA extracts the Access Token and other relevant parameters from the URL and stores them in the browser, whether in memory, sessionStorage or localStorage.

The SPA can now access or action protected resources from the Service Provider by including the header Authorization: Bearer <Access Token> in subsequent requests.

#### Specific Implicit Flow vulnerabilities

1) **URL exposure**

With the Access Token included in the URL, they will be visible in browser history.  

The full URL can also be unwittingly sent on to third party websites as part of the Referer header, if client site's Referrer Policy headers are not configured to prevent this.

2) **Lack of refresh mechanism**

Implicit Flow does not implement any refresh mechanism and doesn't provide refresh_tokens. 

To avoid frequent user re-authorization, the token must be long-lived and stored in browser localStorage. LocalStorage is relatively secure inaccessible from external processes. However as the data stored is persistent, there is a larger window of opportunity for malicious code - whether through an XSS attack or a device compromised by a malicious user, to access sensitive data such as the Access Token.

If tokens are short-lived, frequent user authorization requests are needed, and this could provide a greater opportunity for interception. 

Requiring users to frequently re-authenticate and re-authorize is also detrimental to user experience, especially when the authentication process involves MFA for example.

3) **Redirect URL Interception**

With the Access Token fully exposed in the post-authorization redirection URL, it provides a significant attack vector, far removed from the underlying Implicit Flow process, making potential exploits difficult to predict and defend against.

For example, on older Android and iOS operating systems, a vulnerability existed where multiple apps could be registered to handle the same custom URL scheme e.g. mycustomapp://. A malicious app could in some circumstances intercept a redirection using a scheme intended for a legitmate app, accessing any data in the URL.

#### Deprecation

Due to its inherent vulnerabilities, OAuth 2.0 Implicit Flow has been deprecated, although it is still supported by many Service Providers, including [Spotify](https://developer.spotify.com/documentation/web-api/tutorials/implicit-flow) and [Microsoft Identity Platform](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow#prefer-the-auth-code-flow).

Instead Authorization Code Flow with PKCE is now the recommended standard for applications that cannot securely store a client secret.

Applications implementing Authorization Code Flow with PKCE avoid or mitigate the inherent vulnerabilities of Implicit Flow.


#### Additional authorization code step

Unlike implicit flow, Authorization Code Flow with PKCE includes the intermediate step of providing the client with an authorization code that is later used to exchange for Access Tokens. 

Access Tokens are obtained with an AJAX request to a token-exchange endpoint on the authentication server, which has the sole purpose of certifying a request's authorization code and returning an Access Token. This means the Access Token is not exposed to browser history, referer headers, or malicious browser extensions/scripts. 

Contrast this with implicit flow where the Access Token is returned in a full page redirection URL, visible to the user and stored in browser history.

The PKCE token exchange mechanism can also return refresh tokens giving the same [user-experience benefits](#### Obtaining-fresh-Access-Tokens-with-a-Refresh-Token
) as server-based Authorization Code Flow.

#### Securing the authorization code-Access Token exchange 

In the traditional Authorization Code Flow for server-backed Client Apps, when exchanging the authorization code for an Access Token, the client secret is included so that the Authorization Server knows the request originated from client server and can be trusted.

With SPAs, there is no way to either distribute or store an app-specific client secret securely on the browser.

Authorization Code Flow with PKCE uses a mechanism to certify that an Authorization Code-Access Token request belongs to the same user and Client App instance that initiated the authorization process.

This is what the 'PKCE' (Proof Key for Code Exchange) part of the process is.

Authorization Code Flow with PKCE:

1)
The Client App must first register with the Service Provider, with a client_id and a redirect_uri.

2)
When the user initializes the authorization process, first the Client App uses a [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator) to generate a unique string called the 'code_verifier'.

Then a 'code_challenge' is generated from the 'code_verifier', typically using a secure hash function like SHA-256.

The user's browser is then redirected to the Authorization Server, with the code_challenge and the method used to generate the code_challenge included in the URL:

```
https://authorization-server.com/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=SCOPE&state=STATE&code_challenge=CODE_CHALLENGE&code_challenge_method=S256
```


As with traditional Authorization Code Flow, the redirect_uri is included to be checked with the one registered, as a security measure to prevent bogus requests redirecting the user to malicious sites or clones of the Client App.

State is provided to [protect against CSRF attacks] (*** where state is described ***)

3)

The user then authenticates and grants the Client App the requested scope permissions.

The Authorization Server then creates a temporary Authorization Code, and temporarily saves the code_challenge and the code_challenge_method with this Authorization Code. Later these will be used to verify the token exchange request belongs to the same client and user that inititated the process.

The Authorization Server then redirectes the browser back to the Client App with the temporary Authorization Code:

```
https://my-pkce-client-app.com/callback?code=AUTHORIZATION_CODE&state=STATE
```

4) Token Exchange

The Client App now makes an AJAX POST request to the Authorization Server's token exchange endpoint, with the Authorization Code and the code_verifier included in the URL-encoded form data:

```
    POST /token HTTP/1.1
    Host: authorization-server.com
    Content-Type: application/x-www-form-urlencoded

    grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=REDIRECT_URI&client_id=CLIENT_ID&code_verifier=CODE_VERIFIER
```

Since the Authorization Server knows the code_challenge and code_challenge_method, it will apply the code_challenge_method to the code_verifier to confirm it matches the original code_challenge, and can trust the request.
 
It then returns a JSON response with the Access Token, along with a refresh_token if supported:

```json
    {
      "access_token": "ACCESS_TOKEN",
      "token_type": "bearer",
      "expires_in": EXPIRES_IN,
      "refresh_token": "REFRESH_TOKEN",
      "scope": "SCOPE"
    }
```

5) 

The post-authorization situation is now similar to that of traditional Authorization Code Flow.

The Client App can now access their authorized resources with the Authorization: Bear <Access Token> header, with token refresh capabilities if provided.

## OpenID Connnect - OAuth 2.0 for Authentication

When OAuth 2.0 was developed, it was focused on providing a secure and standardized framework for allowing users to authorize Client Apps without sharing credentials.

OAuth 2.0 had no features specifically for authenticating users with Client Apps via identity providers, to say nothing for administering user roles, claims, and other attributes.

Originally, after OAuth 2.0 gained adoption, developers created their own custom solutions to include authentication. However, these solutions often differed significantly, sometimes leading to inconsistent or insecure implementations.

In response the OpenID Foundation developed a standardized protocol for Authentication with OAuth 2.0 called OpenID Connect (OIDC).

OIDC has been widely adopted and is supported by most identity providers and technology ecosystems including Google and Microsoft.

Since it is built on OAuth 2.0 protocols, knowledge of OAuth 2.0 flows makes it easy to understand OIDC too.

In fact, the changes needed to use OIDC with Authorization Code Flow or Authorization Code Flow with PKCE are so simple we can cover them together in just a few lines.

First, for your user's URL directing them to the Authorization Server, we just need to make sure 'openid' in included in the 'scope' parameter:

https://authorization-server.example.com/authorize?
  response_type=code&
  client_id=client123&
  scope=openid%20profile%20email&
  redirect_uri=https%3A%2F%2Fclient-app.example.com%2Fcallback&
  state=abc123

Second, when the Access Token is received from authorization code exchange, the JSON payload also includes an 'id_token', a JWT containing the authorized user's identity details.


### Authentication and Authorization in one flow

So we've seen how to implement user authentication with OIDC, and how it's a simple extension of OAuth 2.0 Authorization Code Flows.

And OAuth 2.0's function is enabling Client Apps to integrate with Service Providers and access protected resources, without holding user credentials.

As a result, it becomes possible for a user to authenticate with an identity provider, and authorize access to a resource server, in one flow. 

For example, we have built a Client Application that integrates with an e-commerce site. The e-commerce site has an API that allows authorized applications access to its 'resources', which we'll call functionality for this example. This is our resource server. 

Our app is very useful for users of the e-commerce site, as it adds lots of additional funtionality and automation capabilities that the site lacks.

The e-commerce site trusts Google as an identity provider and supports OAuth 2.0.

Lets say User 1, an avid user of the e-commerce site, has a Google account, and our app uses Google as the identity provider. 

With one user flow, User 1 can simultaneously login to our app by authenticating with Google, and also grant our Client App permission to access certain features of the e-commerce site on their behalf. Since integrating with and improving those features is why User 1 likes our app!

To achieve this, we need to make sure that the scopes we include in the initial authorization request include 'openid' for authentication, and the additional scope values defined by the e-commerce site that represent the features we wish to gain access to. The scope values need to be configured with the identity provider and resource server.

Assuming the User 1 has granted authorization, the Authorization Code Flow will send the Client App an Access Token specific for accessing features on behalf of User 1. Other users will have their own Access Tokens, possibly with different permissions, so these need to be stored and used appropriately for our app to function correctly for each user.

###
1. A user has an existing account with a streaming service (e.g. Netflix), (the Service Provider).
2. They have a smart TV with the service's app installed.
3. They wish to authorize this app to use their account (essentially just authenticating with the app).
4. They could authenticate manually through the app, but the user interface on the TV is difficult to use, so instead they authenticate on a user-friendlier device such as their mobile device. Device Authorization Flow is the process that enables this.

A simplified version of the Device Authorization Flow process works as follows:

The streaming app is prompted by the user to authorize.

The streaming app sends a request to the Authorization Server to initiate the authorization process.

The Authorization Server:

1) Geneates a random device code to identify streaming app device being authorized.

2) Geneates a random user code identifying the authorization process being started.

3) Stores these together on the server temporarily, as they will be needed for later verification when the user completes authorization.

4) Sends the streaming app the URL the user must navigate to on their mobile device, including the user code, and the device code:

{
  "device_code": "DEVICE_CODE",
  "authorization_url": "https://authorization.streaming-service.com/user-auth-page?USER_CODE",
}


The device begins making polling requests to the Authorization Server in the background, asking if the device code has been authorized yet. 


The authorization URL can be rendered on the TV as a QR code, that the user can open on their mobile device. The authorization URL will be specific to the streaming service, it will open the streaming service's login page in the browser or the streaming service mobile app itself.

When the user authenticates, or if they are already authenticated, they will simply be asked if they wish to authorize the device app to use their account.

When the user confirms, the Authorization Server looks up the device code for the user in its memory, verifies it matches the device code in the polling requests, and returns an Access Token to the streaming app. 

The Access Token then allows the streaming app access to the user's account.


*****

2) Lack of secure or convenient storage options

With Implicit Flow, the Access Token must be sent in the URL. This means storing it as an HttpOnly cookie, inaccessible to javascript and hence XSS, is not an option.

Session and in-memory storage are options, but they are both still vulnerable to XSS, and inconvenient for the user as they require reauthentication with the Authorization Server whenever the browser is restarted.

Finally localStorage does persist the token across browser-sessions, but the Access Token is vulnerable access from malicious users of the same device, especially considering that Implicit Flow does not implement refresh tokens 

***

#### Notes on terminology

*Service Providers* are *First-party* apps - those that provide the user resources and functionality we wish to integrate with.

*Client Applications* are the *Third-party* apps to be integrated - usually smaller and requiring user-specific resources the service provider has access to.

*Authorization Servers* allow the Client App to authenticate and allows the user to grant the application permissions to resources on the Service Provider.

*Identity Providers* allow the user to authenticate, verifying their identity to any other service that might require it. This could be both the Client App and the Service Provider.

In some cases the functions of the Identity Provider, Authorization Server and Service Provider are all provided by the same service or organisation - for example Facebook provides user authentication, as well as allowing users to grant authorization to third-party applications to access user data, while being the Service Provider at the same time.

However there are plenty of Service Providers that use separate Identity Providers - it's common for an application to allow authentication with multiple providers such as Google, Microsoft, Apple and others. Instances of applications using separate Identity Providers and Authorization Servers are rare. Although they serve different functions, for the purpose of Client App integration they are usually configured together. 

For convenience, examples in this article will assume the Identity Provider and the Authorization Server are the same service, and use the term Authorization Server even when the service is only providing user authentication.


### Implicit Flow Implementation 

Client-side applications are generally considered less secure at storing sensitive information like client secrets. 

In the case of SPAs, source code is accessible, and developer tools make it easy to find secrets stored in the browser. They can be vulnerable to XSS attacks, allowing malicious scripts access to browser storage.

Mobile apps, while often running on platforms that do offer some mechanisms for secure storage, are still vulnerable when faced with a determined attacker armed with reverse-engineering and debugging tools. [Here's a comprehensive explanation](https://ivrodriguez.com/why-embedding-secrets-in-mobile-apps-is-not-a-good-idea/).

OAuth 2.0 has two flows designed specifically for client-side applications, Implicit Flow and Authorization Code Flow with PKCE. Implicit Flow is regarded as an insecure implementation, and has been largely superseeded by the more secure Authorization Code Flow with PKCE.

However let's briefly examine Implicit Flow's implementation and it's vulnerabilities, then show how Authorization Code Flow with PKCE improves on it.


1) **App Registration**

    As with standard Authorization Code Flow, the app is registered with the Service Provider, including a unique *client_id* and a *redirect_uri* that the Authorization Server will direct the user to after authorization.

    *The Client App's domain* - `implicitflow.demoapp.com`

    *client_id* - **ImplicitFlow_DemoApp**
    
    *redirect_uri* - `https://implicitflow.demoapp.com/callback`
    
    *The Authorization Server's authorization endpoint* - `https://auth.service.com/authorize`

2) **User Authorization Request**

    To authorize the Client App, the app constructs a URL pointing to the Authorization Server, along with the query parameters:

    *client_id* - **ImplicitFlow_DemoApp**

    *scope* - The list of permissions the Client App is asking the user to authorize. As before, "profile" is all our demo app requires

    *redirect_uri* - The redirect URI setup in the app registration, `https://implicitflow.demoapp.com/callback`, encoded as a URL parameter

    *state* - A random string value generated by the Client App specifically for the authorization request. As with the Authorization Code Flow, the *state* value is used to [protect against CSRF attacks](#csrf). To ensure uniqueness and unguessabilitity it should be generated with a [CSRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)
    
    We'll keep using 'OurOAuth2StateString' as our dummy state string.

    *response_type* - Always set to 'token' (indicating the Client App wants to receive the Access Token directly)

    When the user wishes to authorize the Client App, this URL is opened in a new tab sending the authorization request as a GET request to the Authorization Server:

    ```
    https://auth.service.com/authorize?response_type=token&client_id=ImplicitFlow_DemoApp&scope=profile&state=OurOAuth2StateString&redirect_uri=https%3A%2F%2Fimplicitflow.demoapp.com%2Fcallback
    ```
    
    In the new tab displaying the Authorization Server's authentication screen, the user authenticates with their credentials and authorizes the app with its requested permissions (defined in the *scope* query parameter).

3) **Access Token Returned** 

    After the user has granted authorization, the user is redirected back to the Client App via the *redirect_uri*. 

    The Access Token, along with the standard OAuth token parameters such as expiry time, are included in the URL as part of the URL fragment:

    ```
    https://implicitflow.demoapp.com/callback#access_token=Acc3ssT0ken&token_type=Bearer&expires_in=3600&state=OurOAuth2StateString
    ```
    The Access Token and other parameters are sent as a URL fragment (everything after the #) because URL fragments aren't sent to the server supporting the SPA. Even if our server does nothing except return SPA application code, it still may log or monitor requests, so the URL fragment prevents the sensitive data being recorded in these logs. 

    Since URL fragments aren't sent to servers, they also avoid being cached by the browser. However they are still recorded in browser history, as discussed below.

4) **Accessing Protected Resources**

    The SPA extracts the Access Token and other relevant parameters from the URL and stores them in the browser, whether in memory, sessionStorage or localStorage.

    As with other flows, now the Access Token is granted, the SPA can make requests for protected resources from the Service Provider by including the header:

    ```
    Authorization: Bearer Acc3ssT0ken 
    ```

#### Specific Implicit Flow vulnerabilities

1) **URL exposure**

    With Access Tokens included in the URL, they will be visible in browser history, as well as accessible to any javascript running on the callback page, making them vulnerable to access through XSS attacks.  

2) **Lack of refresh mechanism**

    Implicit Flow does not implement any refresh mechanism and doesn't provide refresh tokens. 

    To avoid frequent user re-authorization, the token must be long-lived and stored in browser localStorage. LocalStorage has benefit of being inaccessible to external processes. However as the data stored is persistent, there is a larger window of opportunity for malicious code - whether through an XSS attack or a device compromised by a malicious user - to access sensitive data such as the Access Token.

    If tokens are short-lived, frequent user authorization requests are needed, and instead this could provide a greater opportunity for request interception (i.e. a man-in-the-middle attack). 

    Requiring users to frequently re-authenticate and re-authorize is also detrimental to user experience, especially when the authentication process involves MFA, for example.

3) **Redirect URL Interception**

    With the Access Token fully exposed in the post-authorization redirection URL, it provides a significant attack vector independent from the underlying Implicit Flow process, making potential exploits difficult to predict and defend against.

    For example, on older Android and iOS operating systems, a vulnerability existed where multiple apps could be registered to handle the same custom URL scheme e.g. mycustomapp://. A malicious app could in some circumstances intercept a redirection using a scheme intended for a legitmate app, accessing any data in the URL.

#### Deprecation

Due to its inherent vulnerabilities, OAuth 2.0 Implicit Flow has been deprecated, although it is still supported by many Service Providers, including [Spotify](https://developer.spotify.com/documentation/web-api/tutorials/implicit-flow) and [Microsoft Identity Platform](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-implicit-grant-flow#prefer-the-auth-code-flow).

Instead Authorization Code Flow with PKCE is now the recommended standard for applications that cannot securely store a client secret.

Applications implementing Authorization Code Flow with PKCE avoid or mitigate the inherent vulnerabilities of Implicit Flow.

### Authorization Code Flow with PKCE Implemtation

#### Additional Authorization Code step

Unlike implicit flow, Authorization Code Flow with PKCE includes the intermediate step of providing the client with an Authorization Code that is later used to exchange for Access Tokens. 

Access Tokens are obtained with an AJAX request to a token-exchange endpoint on the Authorization Server, which has the sole purpose of certifying a request's Authorization Code and returning an Access Token. This means the Access Token is not exposed in browser history, or malicious browser extensions/scripts. 

Contrast this with Implicit Flow where the Access Token is returned in a full page redirection URL, visible to the user and stored in browser history.

The PKCE token exchange mechanism can also return refresh tokens giving the same [user-experience benefits](#### Obtaining-fresh-Access-Tokens-with-a-Refresh-Token
) as server-based Authorization Code Flow.

#### Securing the Authorization Code-Access Token exchange 

In the traditional Authorization Code Flow for server-backed Client Apps, when exchanging the Authorization Code for an Access Token, the client secret is included so that the Authorization Server knows the request originated from Client App's server and can be trusted.

With SPAs, there is no way to either distribute or store an app-specific client secret securely, considering the multiple browser instaces running the application.

Authorization Code Flow with PKCE uses a mechanism to certify that an Authorization Code-Access Token request belongs to the same user and Client App instance that initiated the authorization process.



Authorization Code Flow with PKCE:

1) **App Registration**

    As with other Client App OAuth 2.0 authorization flows, the Client App must first register with the Service Provider, with a *client_id* and a *redirect_uri*.

    *The Client App's domain* - `pkce.authcodeflow.demoapp.com`

    *client_id* - **PkceAuthCodeFlow_DemoApp**
    
    *redirect_uri* - `https://pkce.authcodeflow.demoapp.com/callback`
    
    *The Authorization Server's authorization endpoint* - `https://auth.service.com/authorize`

2) **User Authorization Request**

    When the user initializes the authorization process, first the Client App uses a [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator) to generate a unique string called the *code_verifier*. 

    The *code_verifier* should be between 43 and 128 characters long, and for the sake of simplicity and easier debugging, should consist of only URL-safe characters that require no encoding (a-z, A-Z, 0-9, hyphens and underscores will work fine).

    Then a *code_challenge* is generated from the *code_verifier*, typically using a secure hash function like SHA-256.

    Let's not use dummy values this time and do this for real with a pseudo-random number for our *code_verifier*:
    
    *code_verifier*: iQhYcRvP8zSxL6mA0tN_fE2DGZ1XjKUokbOeHsn7wYM4-lWpV
    
    We SHA-256 hash the *code_verifier* to get the *code_challenge*: c46b62c38870e17ae9a33b0c901e6665241b54a594dcc981e2ac214897d061c1

    The user's browser is then redirected to the Authorization Server, with the *code_challenge* and the method used to generate the *code_challenge* included in the URL:

    ```
    https://auth.service.com/authorize?response_type=code&client_id=PkceAuthCodeFlow_DemoApp&scope=profile&state=OurOAuth2StateString&code_challenge=c46b62c38870e17ae9a33b0c901e6665241b54a594dcc981e2ac214897d061c1&code_challenge_method=S256&redirect_uri=https%3A%2F%2Fpkce.authcodeflow.demoapp.com%2Fcallback
    ```


    As with traditional Authorization Code Flow, the *redirect_uri* is included to be checked with the one registered, as a security measure to prevent bogus requests redirecting the user to malicious sites or clones of the Client App, along with a [state value](#state), that we check for CSRF safety.


3) **Temporary Authorization Code Granted** 

    The user then authenticates and grants the Client App the requested *scope* permissions.

    The Authorization Server then creates a temporary Authorization Code, and temporarily saves the *code_challenge* and the *code_challenge_method* with this Authorization Code. Later these will be used to verify that the token exchange request belongs to the same Client App, and for the same user, that inititated the process.

    The Authorization Server then redirectes the browser back to the Client App with the temporary Authorization Code:

    ```
    https://pkce.authcodeflow.demoapp.com/callback?code=TempAuth0rizati0nC0de&state=OurOAuth2StateString
    ```

4) **Access Token Exchange**

    The Client App now makes an AJAX POST request to the Authorization Server's token exchange endpoint, with the Authorization Code and the *code_verifier* included in the URL-encoded form data:

    ```
    POST /token HTTP/1.1
    Host: auth.service.com
    Content-Type: application/x-www-form-urlencoded

    grant_type=authorization_code&code=TempAuth0rizati0nC0de&redirect_uri=https%3A%2F%2Fpkce.authcodeflow.demoapp.com%2Fcallback&client_id=PkceAuthCodeFlow_DemoApp&code_verifier=iQhYcRvP8zSxL6mA0tN_fE2DGZ1XjKUokbOeHsn7wYM4-lWpV
    ```

    Since the authorization server knows the *code_challenge* and *code_challenge_method*, it will apply the *code_challenge_method* to the *code_verifier* to confirm it matches the original *code_challenge*, and can trust the request.
     
    It then returns a JSON response with the Access Token, along with a refresh_token if supported:

    ```json
    {
      "access_token": "Acc3ssT0ken",
      "token_type": "Bearer",
      "expires_in": 3600,
      "refresh_token": "Refr3shT0ken",
    }
    ```

5) **Accessing Protected Resources**

    The Client App can now make requests for protected resources in the usual manner, except from the browser if there is no server backend as may be the case in with a SPA. The Access Token is added in the Authorization Header:


    ```
    Authorization: Bearer Acc3ssT0ken
    ```

    If supported by the OAuth 2.0 implementation, the same [Refresh Token mechanism](#obtaining-fresh-access-tokens-with-a-refresh-token) outlined for regular Authorization Code Flow can be used to gain new Access Tokens when they near expiry. 
    

